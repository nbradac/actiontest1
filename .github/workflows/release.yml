name: release
on:
  workflow_dispatch:
    inputs:
      release:
        description: 'is this an actual release?'
        required: true
        type: boolean
        default: false
      fail:
        description: 'should a job fail?'
        required: true
        type: boolean
        default: false
      release-version:
        required: true
        type: string
        default: asdf
      new-version:
        required: true
        type: string
        default: asdf
        
      release-major-version:
        required: true
        type: number
        default: 1
      release-minor-version:
        required: true
        type: number
        default: 50
      release-patch-version:
        required: true
        type: number
        default: 0

      aeron-git-tag:
        description: Aeron OSS git tag
        required: true
        default: origin/HEAD
        type: string

  schedule:
    - cron: '0 12 * * *'

jobs: # these jobs run serially because of the 'needs:' keyword on each

  validation:
    runs-on: ubuntu-latest
    outputs:
      new-sha: ${{ steps.set-sha.outputs.new-sha }}
    steps:
      - name: figure out versions
        id: version-check
        run: |
          major=${{ inputs.release-major-version }}
          minor=${{ inputs.release-minor-version }}
          patch=${{ inputs.release-patch-version }}
          let "minor_incr=minor+1"
          let "patch_incr=patch+1"
          echo $major $minor $patch
          echo $minor_incr $patch_incr
          echo ${{ github.ref }}
          echo "RELEASE_VERSION=$major.$minor.$patch" >> "$GITHUB_OUTPUT"
          [ "${{ github.ref }}" == "refs/heads/master" ] && echo "CREATE_BRANCH=true" >> "$GITHUB_OUTPUT" || echo "CREATE_BRANCH=false" >> "$GITHUB_OUTPUT"
          [ "${{ github.ref }}" == "refs/heads/master" ] && echo "SNAPSHOT_VERSION=$major.$minor_incr.$patch-SNAPSHOT" >> "$GITHUB_OUTPUT" || echo "SNAPSHOT_VERSION=$major.$minor.$patch_incr" >> "$GITHUB_OUTPUT"
          echo "NEW_BRANCH=release-$major.$minor.$patch" >> "$GITHUB_OUTPUT"
          echo "BRANCH_SNAPSHOT_VERSION=$major.$minor.$patch_incr" >> "GITHUB_OUTPUT"

          sleep 1
          cat $GITHUB_OUTPUT
          exit 1
      - name: verify aeron tag
        id: check-tag
        if: ${{ inputs.aeron-git-tag != 'origin/HEAD' }}
        uses: mukunku/tag-exists-action@v1.6.0
        with: 
          tag: '${{ inputs.aeron-git-tag }}'
          repo: 'real-logic/aeron'
      - name: tag does not exist
        if: ${{ inputs.aeron-git-tag != 'origin/HEAD' && steps.check-tag.outputs.exists == 'false' }}
        run: |
          echo "Tag DOES NOT exist!"
          exit 1
    
      #- run: |
      #    [[ "${{ inputs.release-version }}" =~ ^[0-9]\.[0-9][0-9]?\.[0-9][0-9]?$ ]]
      #    [[ "${{ inputs.new-version }}" =~ ^[0-9]\.[0-9][0-9]?\.[0-9][0-9]?$ ]]

      - if: ${{ inputs.release }}
        id: release-yes
        run: |
          echo "NEW_SHA=yes${{ github.sha }}" >> "$GITHUB_ENV"
    
      - if: ${{ !inputs.release }}
        id: release-no
        run: |
          echo "NEW_SHA=no${{ github.sha }}" >> "$GITHUB_ENV"

      - id: set-sha
        run: |
          echo "new-sha=$NEW_SHA" >> "$GITHUB_OUTPUT"

  intermediate:
    runs-on: ubuntu-latest
    needs: validation
    steps:
      -
        run: |
          echo git sha: ${{ github.sha }}
          echo new sha: ${{ needs.validation.outputs.new-sha }}
          exit 1

  ci: # kick off a different workflow - all the normal CI stuff can be neatly isolated
    uses: ./.github/workflows/ci.yml
    needs: intermediate
    with:
      fail: ${{ inputs.fail || false }}
      # could add a 'capture-assets' boolean input option on CI so that it knows if/when to store artifacts for subsequent packaging
      # The normal CI run won't need to store those artifacts - only when it's being run as a 'sub'-workflow of 'release'

  package: # shows retrieving an artifact from the previous step
    runs-on: ubuntu-latest
    needs: ci # wait for the ci job to complete
    steps:
      - name: step1
        run: echo "building some packages"
      - name: Download a single artifact
        uses: actions/download-artifact@v4
        with:
          name: my-artifact
      - name: ls
        run: ls

  tag: # shows how to add a tag to the git repo
    runs-on: ubuntu-latest
    needs: package # wait for package job to complete
    # only execute if this is a release
    if: ${{ inputs.release || false }}
    outputs:
      new-sha: ${{ steps.update-version.outputs.new-sha }} # used by the final-tag job
    steps:
      - name: checkout
        uses: actions/checkout@v4

      - name: output
        run: |
          echo "the current sha: $GITHUB_SHA"

      - name: Create/update tag
        uses: actions/github-script@v7
        with:
          # instead of the default GITHUB_TOKEN, this could be a separate token that only gives permission to add tags
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/release-run-${{ github.run_id }}',            
              sha: context.sha
            })

      - name: update the version file
        id: update-version # need an 'id' here so we can grab the new-sha and store it as an output
        # it's not really a 'version', but it's a value that changes with each run
        run: |
          echo "the ORIGINAL sha: `git rev-parse HEAD`"
          echo ${{ github.run_id }} > version.txt
          echo VERSION=${{ inputs.new-version }} >> version.txt
          git config --global user.name "the 'release' github action"
          git config --global user.email "you@example.com"
          git add version.txt
          git commit -m 'update version'
          git push
          echo "the NEW sha: `git rev-parse HEAD`"
          echo "new-sha=`git rev-parse HEAD`" >> "$GITHUB_OUTPUT"

  final-tag:
    runs-on: ubuntu-latest
    needs: tag
    steps:
      - name: Create/update tag 2
        uses: actions/github-script@v7
        with:
          # instead of the default GITHUB_TOKEN, this could be a separate token that only gives permission to add tags
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/release-run-${{ github.run_id }}-POST',            
              sha: '${{needs.tag.outputs.new-sha}}'
            })
          # the single quotes are important!!!!
      - name: create a file
        run: echo "some data" > some.file
      - name: create release
        uses: softprops/action-gh-release@v2
        with:
          body: "put notable changes here"
          target_commitish: ${{needs.tag.outputs.new-sha}}
          generate_release_notes: true
          name: "release ${{ github.run_number }}"
          tag_name: 'release-run-${{ github.run_id }}'
          files: |
            some.file

  push:
    runs-on: ubuntu-latest
    needs: package
    steps:
      - name: push to release
        if: ${{ inputs.release || false }}
        run: echo "this is where we'd push to the release repo"
      - name: push to dev
        if: ${{ !inputs.release || false }}
        run: echo "this is where we'd push to the dev repo"
      - name: validate packages
        run: echo "validate whatever we find in packages/"